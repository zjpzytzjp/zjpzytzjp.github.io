<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>netty</title>
      <link href="/2023/08/10/netty/"/>
      <url>/2023/08/10/netty/</url>
      
        <content type="html"><![CDATA[<h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><h2 id="netty入门"><a href="#netty入门" class="headerlink" title="netty入门"></a>netty入门</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>ServerBootstrap()  :  启动器，负责组装netty组件，启动服务器</p><p>NioEventLoopGroup() : EventLoop是一个selector加上一个thread就是一个eventloop，即循环处理可读可写事件，既然是group就是组的意思，里面有BossEventLoop和WorkerEventLoop，分别处理accept和读写的事件</p><p>NioServerSocketChannel() : 选择服务器ServerSocketChannel的实现，OIO，BIO</p><p>childHandle：决定了worker（child）能做哪些事情</p><p>channelInitializer：channel代表和客户端进行数据读写的通道， Initializer初始化，负责添加别的handler</p><p>StringDecoder()：将ByteBuf进行解码，转换成字符串</p><p>ChannelInboundHandleAdapter：自定义handler</p><p>bind：绑定监听端口</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Bootstrap() : 启动类</p><p>StringEncoder() : 编码器</p><p>connect：链接哪个服务器</p><p>sync（）：阻塞方法，直到连接建立</p><p>writeAndFlush（）：向服务器发送数据</p><p>channel：就像数据的通道</p><p>msg：流动的数据</p><p>handle：数据的处理工序</p><p>pipeline：工序有多道，就是流水线</p><p>handle分为Inbound 和 Outbound，入站和出站</p><p>eventloop：干活的工人，处理数据</p><ol><li>工人可以管理多个channel 的 io操作，且一个工人只要负责了一个channel，就会绑定，负责到底</li><li>一个工人既可以处理io操作，也可以处理普通任务</li><li>工人按照pipeline的顺序，按序执行handle</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>事件循环对象</p><p>eventloop本质上是一个单线程执行器（同时维护了一个selector），里面有run方法源源不断地处理Channel里面的IO事件</p><p>由于它继承过一个线程池的类，因此包含所有的线程池的方法</p><p>并且还包含判断当前线程是否属于此EventLoop的方法和查看自己属于哪个EventLoopGroup</p><p>事件循环组</p><p>EventLoopGroup是一组EventLoop，Channel会调用EventLoopGroup中的register方法来绑定其中一个eventloop，后续这个channel的IO事件都由此Eventloop执行（保证了IO的线程安全）</p><p>如何实现handle换人，源码分析</p><p><code>static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {     final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);       // 下一个handle的事件循环是否和这个事件循环是一个线程</code></p><p>​<code>EventExecutor executor = next.executor();//返回下一个handle的eventLoop</code></p><p>​<code>// 是，直接调用        if (executor.inEventLoop()) {  ​        next.invokeChannelRead(m); ​    }</code></p><p>​     <code>// 不是，将要执行的代码作为任务提交给下一个事件循环处理</code></p><p><code>else {         executor.execute(new Runnable() { // 如果是外部线程，则提交给异步任务队列             @Override             public void run() {                 next.invokeChannelRead(m);             }         });     } }</code></p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel的主要作用：</p><ol><li>close()关闭chanel</li><li>closeFuture()处理channel的关闭</li></ol><p>​{</p><p>​如果想要在关闭channel后执行一些操作会发现一个问题，那就是因为close方法也是异步调用的方法，这就导致了，写在close方法后的操作不是在真正关闭后执行的，因为close异步的，执行close后会立马执行之后的代码，达不到想要的效果，因此我们需要用closedFuture对象，调用sync方法解决</p><p>​}</p><p>​其中sync()：同步等待channel关闭</p><p>​{</p><p>​如果不适用sync方法会出现问题，因为connect方法是异步非阻塞的，main线程调用了connect，但是实际执行connect的是nio线程，没有sync方法，main方法直接去准备拿channel了，但是那时候connect还没执行完，sync会阻塞当前线程，直到nio线程执行完毕</p><p>​}</p><p>​addlistener：异步等待channel关闭</p><ol start="3"><li>pipeline()添加处理器</li><li>write：写入数据</li><li>writeAndFlush：将数据写入并刷出</li></ol><p>*带有future，promise的类型都是和 异步方法配套使用的</p><p>异步提升的是吞吐量而不是缩短响应时间</p><h3 id="Future-Promise"><a href="#Future-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3><p>jdk的future只能同步</p><p>netty的future可以同步也能异步，但都是等到任务结束才能得到结果</p><p>netty promise脱离了任务独立存在，只作为两个线程传递结果的容器</p><h3 id="channel-1"><a href="#channel-1" class="headerlink" title="channel"></a>channel</h3><p>用来处理Channel的各种事件，分为入站和出站</p><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>所有的handle连成串，就是pipeline</p><p>pipeline.addlast()：添加处理器</p><p>super.channelRead()：把数据传递给下一个handle</p><p>使用channel.write（）会从tail开始往前找，使用ctx会从当前的handle开始往前找</p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>是对字节数据的封装</p><p>创建方法：</p><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);</code></p><h4 id="直接内存和堆内存"><a href="#直接内存和堆内存" class="headerlink" title="直接内存和堆内存"></a>直接内存和堆内存</h4><p>直接内存创建和销毁代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起使用</p><p>直接内存对GC压力小，因为这部分内存不受JVM垃圾回收的管理，但也要及时主动释放</p><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>池化最大的意义在于可以重用bytebuf，如果没有池化，每次都要创建新的bytebuf实例，这个操作对于直接内存代价昂贵，有了池化可以重用bytebuf池中的实例，并且采用内存分配算法提升分配效率，高并发时，池化也更节约内存，防止内存溢出</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230707111444450.png" alt="image-20230707111444450"></p><p>bytebuf有容量和最大容量，容量超了就会开启扩容。</p><p>其中灰色为读指针已经读过的地方，为废弃的，绿色为写指针已经写了，读指针还没读的区域，为可读区域，蓝色部分为容量足够但写指针还没写的区域，为可写区域</p><h4 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h4><p>Netty使用的是引用计数法来控制回收内存，每个bytebuf对象的初始计数为1，调用release方计数减1，如果计数为0，则被回收，调用retain方法计数加一</p><p>由谁来执行release呢？</p><p>谁是最后负责人，谁来执行release。</p><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>零拷贝的体现之一，对bytebuf进行切片成多个Bytebuf，切片后的bytebuf没有发生内存复制，切片后的bytebuf维护独立的read，write指针</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>池化，可以复用池中bytebuf实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像bytebuffer一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用</li><li>很多地方体现了零拷贝，例如slice，duplicate，compositebytebuf</li></ul><h2 id="netty进阶"><a href="#netty进阶" class="headerlink" title="netty进阶"></a>netty进阶</h2><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><p>粘包是因为TCP有一个滑动窗口，滑动窗口缓存了多个报文就会粘包</p><p>半包是滑动窗口不够大，只能把一个报文的一部分装下发送再发送剩下的</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2023/08/10/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/10/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="java语言的特点"><a href="#java语言的特点" class="headerlink" title="java语言的特点"></a>java语言的特点</h3><ul><li>面向对象</li><li>平台无关</li><li>支持多线程</li><li>支持网络编程</li><li>编译与解释并存</li></ul><h3 id="JVM，JRE，JDK"><a href="#JVM，JRE，JDK" class="headerlink" title="JVM，JRE，JDK"></a>JVM，JRE，JDK</h3><p>JVM是java虚拟机，是运行java字节码的虚拟机。JVM在不同系统由不同的JVM实现，目的是使相同的字节码最后能得到相同的结果。JVM是实现java一处编译到处运行的关键所在。</p><p>JRE是java运行时环境，它是运行已编译的java所需要的内容的集合。</p><p>JDK是提供给开发者使用的，能够创建和编译java程序，它包含jre和其他的java所需要的编译器</p><h3 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h3><p>字节码就是JVM可以理解的代码。</p><h3 id="为什么说java编译与解释并存"><a href="#为什么说java编译与解释并存" class="headerlink" title="为什么说java编译与解释并存"></a>为什么说java编译与解释并存</h3><p>因为java同时具备编译型和解释型语言的特征，需要先编译，再解释，java程序编译生成字节码文件，然后被java解释器解释。</p><h3 id="java与c-区别"><a href="#java与c-区别" class="headerlink" title="java与c++区别"></a>java与c++区别</h3><ul><li>java不提供指针来直接访问内存</li><li>java类是单继承的，c++是多继承的</li><li>java有垃圾自动回收机制，不需要程序员手动释放无用内存。</li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="java中的基本数据类型"><a href="#java中的基本数据类型" class="headerlink" title="java中的基本数据类型"></a>java中的基本数据类型</h3><p>java中有8种数据类型</p><p>分别为</p><p>整数型：byte，short，int，long</p><p>浮点型：float，double</p><p>字符型：char</p><p>布尔型：boolean</p><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230718170554535.png" alt="image-20230718170554535"></p><p>记忆方法，从byte，short，int，long字节数从小到大，1,2,4,8，知道字节数就应该知道位数是字节数*2</p><p>其中char为两个字节，特殊记。</p><p>float，到double，4位变8位</p><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>byte，short，Interger，long这四种类型在【-128 ，127】之间的数据进行了缓存，也就是说你创建在这个范围内的数据时，并不会创建新的对象，而是直接从缓存取。</p><p>超出这个范围才会真的创建对象</p><p>两个浮点型并没有实现缓存机制。</p><p>例题：</p><p>Integer i1 = 33;<br>Integer i2 = 33;<br>System.out.println(i1 == i2);// 输出 true</p><p>Float i11 = 333f;<br>Float i22 = 333f;<br>System.out.println(i11 == i22);// 输出 false</p><p>Double i3 = 1.2;<br>Double i4 = 1.2;<br>System.out.println(i3 == i4);// 输出 false</p><h3 id="自动拆箱装箱"><a href="#自动拆箱装箱" class="headerlink" title="自动拆箱装箱"></a>自动拆箱装箱</h3><p>装箱：把基本数据类型变成包装类，调用的是valueof()方法，</p><p>拆箱：把包装类变成基本数据类型，调用的是xxxValue()方法</p><h3 id="为什么浮点数运算时会有精度丢失的风险"><a href="#为什么浮点数运算时会有精度丢失的风险" class="headerlink" title="为什么浮点数运算时会有精度丢失的风险"></a>为什么浮点数运算时会有精度丢失的风险</h3><p>因为计算机存储无限循环的小数的时候不能完全存储，只能阶段，就会导致误差</p><p>可以使用BigDecimal实现浮点数运算</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态变量被static所修饰，它被类中的所有实例所共享，不管有多少个实例，它们共享静态变量，这样静态变量只用被存储一次，节省内存。</p><p>静态变量是通过类名的方式来访问的，也可以用对象名，但是不推荐</p><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p><p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p><p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h3><p>因为静态方法是属于类的，在类加载的时候就会分配内存，而非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p><p>静态方法存在了，非静态成员都还没存在，所以调用属于非法操作。</p><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重载：方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>重写：是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p>其中方法名，参数列表必须相同，如果被private，final，static修饰了就不能被重写</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程是把解决问题的过程拆分成一个个方法，面向对象是先抽象出对象，再执行对象的方法。</p><p>面向对象的程序更易于维护，易复用，易扩展</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p>封装：把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p>多态：父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间必须是继承或者实现关系</li><li>引用类型变量发出的方法调用的是哪个类的方法，必须在程序运行期间才能确定</li><li>多态不能调用只在子类中存在，缺不在父类中存在的方法</li><li>如果子类重写了父类的方法，则调用子类的方法，如果没有则调用父类的方法</li></ul><h3 id="接口和抽象类有什么异同"><a href="#接口和抽象类有什么异同" class="headerlink" title="*接口和抽象类有什么异同"></a>*接口和抽象类有什么异同</h3><p>共同点：</p><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以包含默认实现的方法</li></ul><p>不同点：</p><ul><li>接口主要用来对类进行约束，你实现了某个接口就要实现它的方法，抽象类主要是为了代码复用</li><li>一个类只能由一个父类，但是能有多个接口</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</li></ul><h3 id="深拷贝和浅拷贝，引用拷贝"><a href="#深拷贝和浅拷贝，引用拷贝" class="headerlink" title="深拷贝和浅拷贝，引用拷贝"></a>深拷贝和浅拷贝，引用拷贝</h3><p>浅拷贝：浅拷贝会在堆上创建一个新的对象，不过原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，相对于两个对象公用一个内部对象</p><p>深拷贝：完全复制整个对象，包含这个对象的内部对象</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object类的常用方法"><a href="#Object类的常用方法" class="headerlink" title="Object类的常用方法"></a>Object类的常用方法</h3><p>Object是第一个类，是所有类的父类</p><p>/**</p><ul><li>native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。<br> <em>/<br> public final native Class&lt;?&gt; getClass()<br> /</em>*</li><li>native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。<br> <em>/<br> public native int hashCode()<br> /</em>*</li><li>用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。<br> <em>/<br> public boolean equals(Object obj)<br> /</em>*</li><li>native 方法，用于创建并返回当前对象的一份拷贝。<br> <em>/<br> protected native Object clone() throws CloneNotSupportedException<br> /</em>*</li><li>返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。<br> <em>/<br> public String toString()<br> /</em>*</li><li>native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。<br> <em>/<br> public final native void notify()<br> /</em>*</li><li>native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。<br> <em>/<br> public final native void notifyAll()<br> /</em>*</li><li>native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。<br> <em>/<br> public final native void wait(long timeout) throws InterruptedException<br> /</em>*</li><li>多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。<br> <em>/<br> public final void wait(long timeout, int nanos) throws InterruptedException<br> /</em>*</li><li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念<br> <em>/<br> public final void wait() throws InterruptedException<br> /</em>*</li><li>实例被垃圾回收器回收的时候触发的操作<br> */<br> protected void finalize() throws Throwable { }</li></ul><h3 id="和equals-的区别"><a href="#和equals-的区别" class="headerlink" title="==和equals()的区别"></a>==和equals()的区别</h3><p>==对于基本数据类型和引用类型的作用效果是不同的</p><p>对于基本数据类型来说，比较的是值</p><p>对于引用类型来说，比较的是对象的内存地址</p><p>而equals方法不能用来比较基本数据类型，只能用来判断两个对象是否相等。</p><p>如果类没有重写equals方法，通过equals比较该类的两个对象时，等价于通过==比较</p><p>类重写了equals方法，一般我们都重写equals来比较两个之间的属性是否相等，若属性相等则返回true</p><p>String a = new String(“ab”); // a 为一个引用<br>String b = new String(“ab”); // b为另一个引用,对象的内容一样<br>String aa = “ab”; // 放在常量池中<br>String bb = “ab”; // 从常量池中查找<br>System.out.println(aa == bb);// true<br>System.out.println(a == b);// false<br>System.out.println(a.equals(b));// true<br>System.out.println(42 == 42.0);// true</p><h3 id="为什么要有hashcode"><a href="#为什么要有hashcode" class="headerlink" title="为什么要有hashcode"></a>为什么要有hashcode</h3><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h3 id="为什么重写equals时要重写hashcode"><a href="#为什么重写equals时要重写hashcode" class="headerlink" title="为什么重写equals时要重写hashcode"></a>为什么重写equals时要重写hashcode</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String，StringBuilder，StringBuffer的区别"><a href="#String，StringBuilder，StringBuffer的区别" class="headerlink" title="String，StringBuilder，StringBuffer的区别"></a>String，StringBuilder，StringBuffer的区别</h3><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>string是不可变的</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String对象是不可变的，可以理解为常量，线程安全。</p><p>StringBuffer对线程加了同步锁，所以也线程安全的</p><p>StringBuilder线程不安全</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对String进行改变，都会生成一个新的String对象，然后将指针指向新的String对象。</p><p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="String为什么是不可变的"><a href="#String为什么是不可变的" class="headerlink" title="String为什么是不可变的"></a>String为什么是不可变的</h3><p>保存字符串的数组被final修饰且私有，并且String类没有提供修改字符串的方法</p><p>String类被final修饰导致不能继承</p><h3 id="字符串拼接用“-”还是StringBuilder"><a href="#字符串拼接用“-”还是StringBuilder" class="headerlink" title="字符串拼接用“+”还是StringBuilder"></a>字符串拼接用“+”还是StringBuilder</h3><p>java本身不支持重载，+和+=是专门为String重载的运算符，</p><p>+实际上是提供StringBuilder调用append方法实现的，拼接完成后调用toString得到一个String对象</p><p><strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p>// 在堆中创建字符串对象”ab“<br>// 将字符串对象”ab“的引用保存在字符串常量池中<br>String aa = “ab”;<br>// 直接返回字符串常量池中字符串对象”ab“的引用<br>String bb = “ab”;<br>System.out.println(aa==bb);// true</p><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p>会创建 1 或 2 个字符串对象。</p><p>如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</p><p>如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><p>// 在堆中创建字符串对象”Java“<br>// 将字符串对象”Java“的引用保存在字符串常量池中<br>String s1 = “Java”;<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s2 = s1.intern();<br>// 会在堆中在单独创建一个字符串对象<br>String s3 = new String(“Java”);<br>// 直接返回字符串常量池中字符串对象”Java“对应的引用<br>String s4 = s3.intern();<br>// s1 和 s2 指向的是堆中的同一个对象<br>System.out.println(s1 == s2); // true<br>// s3 和 s4 指向的是堆中不同的对象<br>System.out.println(s3 == s4); // false<br>// s1 和 s4 指向的是堆中的同一个对象<br>System.out.println(s1 == s4); //true</p><h3 id="String变量和常量相"><a href="#String变量和常量相" class="headerlink" title="String变量和常量相+"></a>String变量和常量相+</h3><p>String str1 = “str”;<br>String str2 = “ing”;<br>String str3 = “str” + “ing”;<br>String str4 = str1 + str2;<br>String str5 = “string”;<br>System.out.println(str3 == str4);//false<br>System.out.println(str3 == str5);//true<br>System.out.println(str4 == str5);//false</p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="exception和error区别"><a href="#exception和error区别" class="headerlink" title="exception和error区别"></a>exception和error区别</h3><p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p><p>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>简单来说：</p><ul><li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>数据输入到计算机内存就是输入，反之输出到外部存储就是输出</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发</title>
      <link href="/2023/08/10/java%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/08/10/java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>当一个程序被运行时，从磁盘加载这个程序的代码到内存时，就开启了一个进程</p><p>一个进程就是一个程序的实例</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以有多个线程</p><p>一个线程就是一个指令流，将指令按照一定顺序交给CPU去执行</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>进程基本相互独立，而线程在进程内的，是进程的一个子集</p><p>进程具有共享的资源，如内存空间等，供其内部线程共享</p><p>进程间的通信较为复杂，而线程共享进程的内存，通信较为简单</p><p>线程上下文切换的成本比进程低</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>是同一时间应对多件事件的能力</p><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>是同一时间处理多件事件的能力</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>调用方法后需要等待结果的返回，才能继续运行就是同步</p><p>不需要等待结果返回，就能运行就是异步</p><h2 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h2><h3 id="方法一：Thread"><a href="#方法一：Thread" class="headerlink" title="方法一：Thread"></a>方法一：Thread</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span>Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token comment" spellcheck="true">// run 方法内实现了要执行的任务</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="方法二：Runnable"><a href="#方法二：Runnable" class="headerlink" title="方法二：Runnable"></a>方法二：Runnable</h3><p>把线程和任务分开，Thread表示线程，Runnable表示可执行的任务</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建任务对象</span>Runnable task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字</span>Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task2<span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>小结：用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。</p><h3 id="方法三：FutureTask配合Thread"><a href="#方法三：FutureTask配合Thread" class="headerlink" title="方法三：FutureTask配合Thread"></a>方法三：FutureTask配合Thread</h3><p>FutureTask 能够接受Callable类型的参数，用来处理有返回结果的情况</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 实现多线程的第三种方法可以返回数据</span>        FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"多线程任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 主线程阻塞，同步等待 task 执行完毕的结果</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">,</span><span class="token string">"我的名字"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>Future就是对具体的Runnable和Callable任务的执行结果进行取消，是否完成，获取结果，必要时通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><pre><code>public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>Future提供了三种功能： 　　</p><ol><li>判断任务是否完成； 　　</li><li>能够中断任务； 　　</li><li>能够获取任务执行结果。</li></ol><p><a href="https://gitee.com/link?target=https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag">https://gitee.com/link?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FRX5rVuGr6Ab0SmKigmZEag</a></p><h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><p>虚拟机栈描述的是java方法执行的内存模型，每个方法被执行时都会同时创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法信息等信息，是属于线程自己私有的。每个线程都维护了自己的栈帧，每个线程只有有一个活动栈帧，对应正在执行的方法</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>因为一些原因，CPU不再进行当前线程，切换成其他线程</p><ul><li>线程自己的CPU时间片用完</li><li>垃圾回收</li><li>更高优先级的线程需要运行</li><li>线程自己调用了sleep，yield，wait，join，synchronized，park，lock等方法</li></ul><p>当上下文切换的时候，操作系统需要保存线程当前的状态，并恢复另一个线程的状态，java使用程序计数器来实现，它的作用就是记录下一条jvm指令的执行地址，它是线程私有的</p><h2 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>程序在t1线程运行，run()方法里面调用的内容是异步的</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token annotation punctuation">@Override</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"我是一个新建的线程正在运行中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              FileReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"新建线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre><code>11:59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程11:59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中11:59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...11:59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms</code></pre><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>将start改成run的话，程序仍然在main线程运行，run里面调用的内容还是同步的</p><p>总结：使用run是在主线程执行了run方法，没有新开启一个线程，使用start是启动新的线程，在新的线程里面间接执行run方法中的代码</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul><li>sleep方法会使当前线程从Running变成Time wating状态</li><li>其他线程可以通过interrupt来打断当前正在睡眠的线程</li><li>睡眠结束的线程并不会立马得到执行，需要等待时间片的分配</li><li>建议用TimeUnit的sleep方法代替Thread的sleep方法，更易读</li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>调用yield会让当前的线程从Running变成Runnable就绪态</li><li>可能没有其他线程正在执行，虽然调用了yield，但是还是分配给了当前线程</li></ul><p>小结</p><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>调用join()方法的线程会被阻塞，直到目标线程执行完成。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"结果为:{}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>主线程会等待t1线程执行完后再执行</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><ul><li>打断sleep，yield，join的线程，会被清空中断状态，即中断状态设置为<code>false</code></li><li>打断正确运行的线程，线程并不会暂停，只是调用方法<code>Thread.currentThread().isInterrupted();</code>的返回值为true，可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li><li>终止模式之两阶段终止模式：考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。那么线程的<code>isInterrupted()</code>方法可以取得线程的打断标记，如果线程在睡眠<code>sleep</code>期间被打断，打断标记是不会变的，为false，但是<code>sleep</code>期间被打断会抛出异常，我们据此手动设置打断标记为<code>true</code>；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为<code>true</code>。处理好这两种情况那我们就可以放心地来料理后事啦！</li></ul><h2 id="sleep，yield，wait，join区别"><a href="#sleep，yield，wait，join区别" class="headerlink" title="sleep，yield，wait，join区别"></a>sleep，yield，wait，join区别</h2><p>sleep不释放锁，释放CPU，join释放锁，抢占CPU，yield不释放锁，释放CPU，wait释放锁，释放CPU</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>默认情况下Java程序需要等待所有线程都执行完才停止，但是守护进程不一样，在其他线程全部结束的时候，即使守护线程没执行完也会被结束</p><h2 id="线程五种状态"><a href="#线程五种状态" class="headerlink" title="线程五种状态"></a>线程五种状态</h2><ul><li>初始状态：只是在语言层面创建了线程对象，没有与操作系统连接上</li><li>可运行状态：已经和操作系统链接，等待CPU分配时间片就能变成运行状态</li><li>运行状态：分配到了时间片，运行自己的线程，等到时间片用完，转换至可运行状态，再次等待时间片</li><li>阻塞状态：如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】，等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】，与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li><li>终止状态：线程已经执行完毕，生命周期已经结束，不会再转变成其他状态</li></ul><h2 id="线程状态之六种状态"><a href="#线程状态之六种状态" class="headerlink" title="线程状态之六种状态"></a>线程状态之六种状态</h2><p><img src="https://upload-images.jianshu.io/upload_images/4840092-f85e70e2262b7878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1155/format/webp" alt="img"></p><h2 id="线程出现问题的根本原因分析"><a href="#线程出现问题的根本原因分析" class="headerlink" title="线程出现问题的根本原因分析"></a>线程出现问题的根本原因分析</h2><p>线程出现问题的根本原因是线程的上下文切换，导致线程还没执行完就执行了下一个线程</p><p>两个线程从主存中读取数据进行修改，可能存在线程1修改后CPU时间片就已经被用完了，导致没有把修改数据写回主存，线程2读取到的就是原始数据，导致出错</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是对象锁，它采用互斥的 方式让同一时刻只有一个线程持有对象锁，其他线程获取这个锁就会被阻塞住</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Object room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span>             counter<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span>             counter<span class="token operator">--</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>synchronized实际上利用对象锁保证了临界区代码的原子性，临界区的代码在外界看来是不可分割的，不会被线程切换打断</p><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ol><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ol><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808095923580.png" alt="image-20230808095923580"></p><p>对象加锁就是在对象的对象头处指向monitor的地址，并且把monitor的owner变成该线程对象，之后的线程发现monitor已经有主人了，只能去entryList中阻塞住</p><p>（synchronized必须关联到同一个对象才有效果）</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果一个对象虽然有多个线程访问，但是访问时间是错开的，也就是没有竞争，那么就可以使用轻量级锁进行优化</p><p>轻量级锁的语法是synchronized，不需要做什么改变</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 同步块 A</span>         <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 同步块 B</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808102110948.png" alt="image-20230808102110948"></p><p>首先需要明确的是轻量级锁是不用使用monitor的，而是采取其他的方式</p><ul><li><p>首先创建锁对象，线程的每个栈帧中会有一个锁对象的结构，内部可以存储锁定对象的MarkWord</p></li><li><p>让锁对象中的object reference指向锁对象，并尝试用CAS的方式去交换对象中的MarkWord，将MarkWord的值存入锁记录，交换就是为了加锁，因为轻量级锁的状态为00，普通情况是01</p></li><li><p>如果cas操作成功，对象头中存的就是锁记录的地址和状态00，表示给该对象加了锁</p><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808111135451.png" alt="image-20230808111135451"></p></li><li><p>如果操作失败，其他线程已经对象加锁了，那么就会进行锁竞争，锁升级</p></li><li><p>如果操作失败，还可能是因为自己锁重入了，自己在线程中在创建出一个锁记录，去尝试加锁，但是发现是自己的线程加了锁，那么加锁会失败，但是锁记录还是会被创建出来，里面记录的是null。</p></li><li><p>解锁的时候，如果有取值为null的锁记录，代表有锁重入，重置锁记录，表示重入计数减一</p></li><li><p>如果不为null的锁记录，代表是第一个锁记录，cas去交换去解锁，成功则解锁成功，失败证明已经有其他线程锁升级了，那么走锁膨胀之后的解锁流程</p></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808144516911.png" alt="image-20230808144516911"></p><p>锁膨胀就是当出现了线程竞争的时候，把轻量级锁转换成重量级锁的过程。</p><p>当Thread1尝试对object加锁的时候，发现它的地址为00，说明已经被加锁了，那么就为object申请一个monitor，把object的对象头指向monitor，把owner设置为thread0，而自己去monitor的entryList里面去阻塞。</p><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808144820814.png" alt="image-20230808144820814"></p><p>当thread0想要解锁的时候，发现object的对象头已经指向了monitor，证明有线程竞争的情况出现，这时进入重量级锁的解锁流程，即按照monitor地址找到monitor对象，把Owner设置为空，唤醒entryList中的线程。</p><h2 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h2><p>重量级锁竞争的时候，还可以通过自旋的方式来进行优化，如果当前线程自旋成功，即持锁线程已经退出了同步代码块，这时就可以避免出现阻塞的情况。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在调用synchronized的时候不再用锁记录替换MarkWord，用ThreadID来替换MarkWord，之后再调用synchronized的时候就只检查ThreadID是不是自己的，是自己的就不用进行CAS了，相当于节省了CAS导致的性能开销。</p><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230808151107468.png" alt="image-20230808151107468"></p><p>如图，biased_lock的值表示是否开启了偏向锁，默认是开启的</p><ol><li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这时它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值</li><li>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</li><li>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</li></ol><h3 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h3><p>hashcode方法会撤销偏向锁，因为使用偏向锁用了原本应该存hashcode的位置去存线程ID，没地方存hashcode了</p><p>其他线程使用对象会撤销偏向锁，当第二个线程尝试获取对象锁的时候，发现本来对象偏向的是线程一，那么偏向锁就会失效，加的就是轻量级锁。</p><p>调用notify/wait方法会撤销偏向锁，直接变成重量级锁，因为这两个方法只有重量级锁可以持有</p><h2 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h2><p>如果对象被多个线程访问，但是没有竞争，这时偏向线程一的对象又有机会重新偏向线程2，但是需要超过20个对象对同一个线程撤销偏向，才能在20个之后的对象偏向线程2</p><h2 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h2><p>如果超过40个对象对同一个线程撤销偏向，jvm就会觉得自己果然偏向错误，就会把所有对象变成不可偏向，新建的对象也是不可偏向的</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>JIT会对完全不会被共享的资源加锁的操作进行锁消除来保障性能。</p><h2 id="wait，notify"><a href="#wait，notify" class="headerlink" title="wait，notify"></a>wait，notify</h2><p><img src="C:\Users\zoujiapeng\AppData\Roaming\Typora\typora-user-images\image-20230809091012337.png" alt="image-20230809091012337"></p><p>owner线程发现条件不满足就会调用wait方法到waitset里面变成waiting状态</p><p>blocked和wating状态都属于阻塞状态，不占用CPU时间片</p><p>blocked线程会在owner线程释放锁的时候被唤醒</p><p>waiting状态会在owner调用notify，notifyall的时候被唤醒，唤醒后重新进入EntryList里面去竞争，不会立马获得锁</p><p>notify唤醒的是waitset里面随机的一个</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用一个共享对象作为锁</span>Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 第一个线程</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>条件成立<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 处理中断异常</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 干活</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 另一个线程</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 修改条件</span>    条件成立 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>一个线程等待另一个线程的执行结果</p><p>有一个结果需要从一个线程传递到另一个线程，就把它们关联到同一个Guardobject</p><p>如果有结果不断从一个线程到另一个线程就用消息队列</p><p>jdk中join，future就是采用这个模式</p><p>需要等待返回结果的是同步模式</p><p><img src="https://gitee.com/gu_chun_bo/java-construct/raw/master/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1594473284105.png" alt="1594473284105"></p><h2 id="join-1"><a href="#join-1" class="headerlink" title="join"></a>join</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// join方法向外抛出了异常，所以使用join方法需要在外层处理异常或者继续向上抛出异常</span><span class="token comment" spellcheck="true">// 我们可以看到这个方法是被synchronized修饰的方法，假设当前线程是A，线程A执行了线程对象B的join方法，</span><span class="token comment" spellcheck="true">// 那么线程A进入到join方法中，就会获取到对象B的对象锁，之所以要用synchronized修饰join方法，就是为了获取B的对象锁，</span><span class="token comment" spellcheck="true">// 因为join方法底层是利用wait方法实现的，而调用某个对象的wait方法需要持有该对象的锁才行</span><span class="token comment" spellcheck="true">// 下面的所有讲解就是按照假设当前线程是A，线程A执行了线程对象B的join方法的前提下讲的，此时join方法就是在线程对象B中</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下面整个代码环境都是在对象B中的，所以里面直接调用的方法按照Java语法规则，只要没有指定方法所在的对象，那么就都是调用的当前所在对象中的方法，也就是线程对象B中的方法</span>    <span class="token comment" spellcheck="true">// 获取当前时间</span>    <span class="token keyword">long</span> base <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 传参小于0，非法参数，抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"timeout value is negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 传入0超时时间意味着永远等待，直到B线程执行完毕</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个isAlive()是线程对象B中的方法</span>        <span class="token comment" spellcheck="true">// isAlive()方法检查的是调用该方法的线程对象对应的线程是否还在运行，也就是检查线程B（被等待线程）是否在还在运行</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果B线程还在执行，则当前线程A会调用wait()方法使自己阻塞（等待），直到被等待的B线程执行结束当前线程才会继续执行。</span>            <span class="token comment" spellcheck="true">// 下面这个wait放大，是线程对象B的wait方法，当前线程A执行了对象B的wait方法，使得当前线程阻塞等待。因为join方法被synchronized修饰，所以当前线程已经持有了对象B的锁了，才能调用B对象的wait方法</span>            <span class="token comment" spellcheck="true">// 传入0也表示没有等待期限，只有当某个线程调用了B对象的notify()/notifyAll()方法，才有可能会使在对象B上的等待队列中等待的线程A唤醒</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 传入的超时时间不为0，意味着如果当前线程A等待了超过millis毫秒了，线程对象B对应的线程还没有执行完，那么也会自动被唤醒继续向下执行，不会一直等待了  </span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 最多等待 millis 毫秒</span>        <span class="token comment" spellcheck="true">// isAlive()判断线程B是否执行完成</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 每一轮循环都会重新计算还剩下多少等待时间，用最多的等待时间减去当前的时间</span>            <span class="token keyword">long</span> delay <span class="token operator">=</span> millis <span class="token operator">-</span> now<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果delay小于等于0了，说明已经到了等待时间了，这个时候不管线程B是否执行完了，都直接跳出循环，后续会去唤醒当前线程A</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果此时还没有超时并且线程B没有执行完，那么就当前线程A就继续调用线程对象B的wait方法，并且传入最多还要等待的时间，来使当前线程阻塞指定的时间</span>            <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 每一轮循环都会获取一次当前的时间</span>            now <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// join方法执行到最后，JVM底层会去执行让当前线程A唤醒的操作，源码中并没有显式调用notify()/notifyAll()方法，整个唤醒操作是在JVM底层实现的</span><span class="token punctuation">}</span></code></pre><p>join方法是用于让一个线程等待另一个线程执行完毕的方法，当一个线程A执行了线程B的join方法后，线程A就会被挂起，直到线程B执行完毕</p><p>join方法的底层实现是基于对象的wait（）和notify（）实现的。线程B执行完毕后就会由JVM自动调用notifyAll()方法通知所有等待在该对象上的线程去唤醒，线程A会重新进入就绪状态</p><p>注意点1：join阻塞的是当前线程，并不是join方法的线程对象对应的线程</p><p>注意点2：唤醒当前线程的notifyAll在JVM底层实现，并不是显式调用的</p><h2 id="多任务版-GuardedObject"><a href="#多任务版-GuardedObject" class="headerlink" title="多任务版 GuardedObject"></a>多任务版 GuardedObject</h2><p>多任务版 GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。和生产者消费者模式的区别就是：这个生产者和消费者之间是一一对应的关系，但是生产者消费者模式并不是。rpc框架的调用中就使用到了这种模式。</p><p><img src="https://gitee.com/gu_chun_bo/java-construct/raw/master/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1594518049426.png" alt="1594518049426"></p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h2 id="异步模式之生产者消费者"><a href="#异步模式之生产者消费者" class="headerlink" title="异步模式之生产者消费者"></a>异步模式之生产者消费者</h2><ul><li>与保护性暂停不同的是，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用于平衡生产和消费的线程资源</li><li>生产者仅负责生产结果数据，不关心怎么处理</li></ul><p><img src="https://gitee.com/gu_chun_bo/java-construct/raw/master/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1594524622020.png" alt="1594524622020"></p><h2 id="park，unpark"><a href="#park，unpark" class="headerlink" title="park，unpark"></a>park，unpark</h2><p>使用方法：LockSupport.park()//暂停</p><p>​   LockSupport.unpark()//恢复</p><p>原理：</p><p>每个线程都有自己的Parker对象，有三部分组成，_counter, _cond和 _mutex</p><p>先调用park：</p><ul><li>调用Unsafe.park()方法</li><li>检查_count，为0则获得_mutex的互斥锁</li><li>线程进入_cond条件变量阻塞</li><li>设置_counter = 0</li></ul><p>先调用unpark</p><ul><li>调用Unsafa.unpark,将count变成1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ul><p> 先调用upark再调用park的过程</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><ol><li><p>RUNNABLE &lt;–&gt; WAITING</p><ol><li>线程用synchronized(obj)获取了对象锁后<ol><li>调用obj.wait()方法时，t 线程从RUNNABLE –&gt; WAITING</li><li>调用obj.notify()，obj.notifyAll()，t.interrupt()时<ol><li>竞争锁成功，t 线程从WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从WAITING –&gt; BLOCKED</li></ol></li></ol></li></ol></li><li><p>RUNNABLE &lt;–&gt; WAITING</p><ol><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ol></li><li><p>RUNNABLE &lt;–&gt; WAITING</p><ol><li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING 注意是当前线程在t 线程对象的监视器上等待</li><li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li></ol></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ol><li>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ol><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ol></li></ol></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ol><li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING 注意是当前线程在t 线程对象的监视器上等待</li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ol></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ol><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒或调用了线程 的 interrupt() ，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ol></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING</p><ol><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ol></li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个线程需要同时获得多个锁，比如t1线程获得了A锁，又想要获得B锁，然后t2线程获得了B锁，又想要获得A锁，这就会导致死锁。</p><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>检测死锁可以使用 jconsole工具；或者使用 jps 定位进程 id，再用 jstack 定位死锁</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>有以下特点</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量，即对满足不同条件的线程放到不同的条件变量里面</li><li>支持可重入</li></ul><pre><code>// 获取锁reentrantLock.lock();try { // 临界区} finally { // 释放锁 reentrantLock.unlock();}</code></pre><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>是同一个线程如果首次获得一把锁，那么因为它是锁的持有者，可以再次获得这把锁，不可重入的锁自己也会被锁住</p><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>再锁竞争进入等待的时候可以被打断，用interrupt</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>用trylock()，获取锁失败后不会无限制等待下去，而是会走try，catch的catch直接获取失败，释放掉锁，</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>默认是非公平锁，公平锁会降低并发度，一般没必要。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p> ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</p><p>即多个waitSet</p><h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2023/08/10/redis/"/>
      <url>/2023/08/10/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h3><p>一方面是因为它是内存数据库，所有操作都在内存中实现，内存的访问速度非常快。</p><p>另一方面，归功于它的数据结构，高效的数据结构是redis快速处理数据的基础</p><h3 id="redis有哪些数据类型"><a href="#redis有哪些数据类型" class="headerlink" title="redis有哪些数据类型"></a>redis有哪些数据类型</h3><p>redis有string，list，hash，sorted set，set类型，其中除了string外都是集合数据类型，一个键对应了一个集合</p><p>它们的底层实现如下：</p><p><img src="https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg?wh=4000*1188" alt="img"></p><h3 id="键和值之间使用的是什么结构组织"><a href="#键和值之间使用的是什么结构组织" class="headerlink" title="键和值之间使用的是什么结构组织"></a>键和值之间使用的是什么结构组织</h3><p>键和值之间是使用的哈希表的形式组织起来的，使用了一个哈希表来保存所有的键值对。我们也称它为全局哈希表。</p><p>那么既然除string类型的四种数据类型的值是集合，那么本质是数组的哈希表是如何来存储他们的呢？</p><p>其实数组的每个元素都是一个哈希桶，它保存的是两个指针，一个指向实际的键和值，这样一来，即使值是一个集合，也可以通过指针找到。</p><p>这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希冲突就是有一些 key 的哈希值对应到了同一个哈希桶中</p><p>解决方法：链式哈希，也就是同一个哈希桶的元素按照链表存储，它们之间用指针来链接。</p><p>问题：链表必须要通过指针逐一查找，效率低，速度慢，因此要避免过长的链表</p><p>解决方案：rehash操作，也就是增加现有的哈希桶数量</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>redis默认使用两个全局哈希表，哈希表1和哈希表2。</p><p>步骤：</p><p>1.将哈希表2的容量扩容，比如扩容成哈希表1的两倍</p><p>2.将哈希表1的数据重新映射拷贝到哈希表2中</p><p>3.释放哈希表1的空间</p><p>但是这其中的第二个步骤涉及到大量的拷贝操作，如果redis一次性进行所以拷贝操作会线程阻塞，无法服务其他请求。因此采用了渐进式rehash。</p><p>简单说就是在拷贝数据的时候正常处理请求，每处理一个请求，就从哈希表1的第一个索引开始，顺带把这个索引位置下的所有entry拷贝到哈希表2中去，第二个请求就从哈希表1的下一个索引开始拷贝。这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><h3 id="有哪些底层数据结构"><a href="#有哪些底层数据结构" class="headerlink" title="有哪些底层数据结构"></a>有哪些底层数据结构</h3><p>整数数组、双向链表、哈希表、压缩列表和跳表。</p><p>压缩列表：实际是一个数组，和数组不同的是压缩列表有zlbyte，zltail，zllen三个字段，分别表示，列表长度，列表偏移量，列表中entry的个数。表尾还有一个zlend</p><p>压缩列表定位第一个元素和最后一个元素可以通过三个字段直接定位，复杂度为O（1）。</p><p>跳表：跳表在链表的基础上加上了多级索引，通过索引位置的几次跳转来实现数据的快速定位。</p><img src="https://static001.geekbang.org/resource/image/1e/b4/1eca7135d38de2yy16681c2bbc4f3fb4.jpg?wh=1878*1126" alt="img" style="zoom: 33%;"><p>当数据量很大时，跳表的查找复杂度就是 O(logN)</p><h3 id="整数数组和压缩列表在查找时间复杂度上不占优势，为什么redis仍然使用"><a href="#整数数组和压缩列表在查找时间复杂度上不占优势，为什么redis仍然使用" class="headerlink" title="整数数组和压缩列表在查找时间复杂度上不占优势，为什么redis仍然使用"></a>整数数组和压缩列表在查找时间复杂度上不占优势，为什么redis仍然使用</h3><p>1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</p><p> 2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</p><h3 id="Redis的单线程"><a href="#Redis的单线程" class="headerlink" title="Redis的单线程"></a>Redis的单线程</h3><p>redis的单线程主要指的是网络IO 和键值对读写的时候是由一个线程完成的。但其实redis的持久化，异步删除，集群数据同步等操作是由额外的线程来执行的。</p><p>为什么用单线程：</p><p>首先要知道多线程的开销，多线程编程模式面临共享资源的并发访问控制问题。</p><h3 id="单线程redis为什么会这么快"><a href="#单线程redis为什么会这么快" class="headerlink" title="单线程redis为什么会这么快"></a>单线程redis为什么会这么快</h3><p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。</p><p>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><h3 id="基于多路复用的高性能IO模型"><a href="#基于多路复用的高性能IO模型" class="headerlink" title="基于多路复用的高性能IO模型"></a>基于多路复用的高性能IO模型</h3><p>在redis只运行单个线程的情况下，该机制允许内核同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字的链接情况和数据情况，一旦有请求到达，立马通知redis线程处理，这就实现了redis单线程同时处理多个IO流的效果。</p><img src="https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg?wh=3472*2250" alt="img" style="zoom: 25%;"><p>为了保证请求到达时，可以及时通知redis线程，select/epoll提供了事件回调机制，即针对不同事件的发生，调用相应的处理函数。</p><p>回调机制：select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放入一个事件队列，redis单线程对该事件队列不断进行处理，并且调用对应事件回调函数。</p><h3 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h3><h4 id="AOF机制"><a href="#AOF机制" class="headerlink" title="AOF机制"></a>AOF机制</h4><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>redis先执行命令，把数据写入内存，然后才记录日志。AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><p>避免出现记录错误命令的情况。它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</p><h4 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h4><p>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</p><p>​其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</p><h4 id="写回策略："><a href="#写回策略：" class="headerlink" title="写回策略："></a>写回策略：</h4><p>​Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p>​Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p>​No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><p><img src="https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg?wh=2284*682" alt="img"></p><h4 id="AOF文件过大导致的问题："><a href="#AOF文件过大导致的问题：" class="headerlink" title="AOF文件过大导致的问题："></a>AOF文件过大导致的问题：</h4><p>一是，文件系统本身对文件大小有限制，无法保存过大的文件；</p><p>二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</p><p>三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</p><h4 id="因此需要AOF重写日志的出现"><a href="#因此需要AOF重写日志的出现" class="headerlink" title="因此需要AOF重写日志的出现"></a>因此需要AOF重写日志的出现</h4><p>：就是在redis重写时，根据数据库中现有的键值对创建一个新的AOF文件，每一个键值对都用一个命令来存储。由于AOF文件是追加记录的，可能某一个键值对被多次修改，重写日志只保留它的最新状态，这样大大降低了AOF的大小</p><p><img src="https://static001.geekbang.org/resource/image/65/08/6528c699fdcf40b404af57040bb8d208.jpg?wh=4000*1088" alt="img"></p><h4 id="重写会阻塞主线程吗？"><a href="#重写会阻塞主线程吗？" class="headerlink" title="重写会阻塞主线程吗？"></a>重写会阻塞主线程吗？</h4><p>不会，重写是在子线程中进行的，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p><h3 id="内存快照"><a href="#内存快照" class="headerlink" title="内存快照"></a>内存快照</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>内存中的数据某一刻的状态记录。对redis来说，就是把某一时刻的状态以文件的形式存入磁盘，RDB记录的是数据，不是AOF的命令，所以数据恢复起来很快。</p><h4 id="给哪些数据做快照"><a href="#给哪些数据做快照" class="headerlink" title="给哪些数据做快照"></a>给哪些数据做快照</h4><p>做的是全量快照，也就是内存中的所有数据。redis默认做快照是用bgsave，它会创建一个子进程，所以不会阻塞主线程。</p><h4 id="快照时数据能修改吗"><a href="#快照时数据能修改吗" class="headerlink" title="快照时数据能修改吗"></a>快照时数据能修改吗</h4><p>为了避免快照导致的不能写操作的情况，redis采用了操作系统的写时复制技术。</p><p>即如果快照时要修改数据则把那个数据做个复制，在数据副本上进行修改，而子进程继续进行快照的存储。</p><p><img src="https://static001.geekbang.org/resource/image/a2/58/a2e5a3571e200cb771ed8a1cd14d5558.jpg?wh=13333*7500" alt="img"></p><h4 id="多久做一次快照"><a href="#多久做一次快照" class="headerlink" title="多久做一次快照"></a>多久做一次快照</h4><p>快照间隔越短对数据恢复越好，但是如果频繁地执行全量快照，也会带来两方面的开销。</p><p>一方面，大量数据写入磁盘，给磁盘带来很大的压力。</p><p>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。</p><p>如何解决：做增量快照，即后续的快照只对修改的数据进行快照记录，这样就可以避免每次全量快照带来的开销。</p><p>但是为了达到“记住哪些数据被修改的效果”也需要消耗很多资源。</p><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><h3 id="主从库"><a href="#主从库" class="headerlink" title="主从库"></a>主从库</h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>redis采用主从库模式的方式来保证数据一致性，主从库采用的是读写分离方式</p><p>读操作：主库和从库都可以进行读操作</p><p>写操作：首先在主库操作，再将数据同步给从库</p><h4 id="为何读写分离"><a href="#为何读写分离" class="headerlink" title="为何读写分离"></a>为何读写分离</h4><p>如果客户端对同一个数据修改了三次，每次修改请求都被分发给了不同的库，那么这三个库中的数据就不一致了，读取这个数据的时候就有可能读取到旧的值。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>首先，从库发送指令给主库，请求同步，主库接收到请求后，生成一个RDB文件，并且把所有数据都存进去，如何发给从库，从库接收到数据后，会把自己当下的数据清空，如何再装入主库来的数据。在主库把数据传给从库的过程中，主库不会阻塞，仍然在接受请求，但这些请求中的写操作并没有同步到刚刚的RDB文件中，所以redis在内存中专门的replication buffer中记录的修改发送给从库，从库再执行这些修改，达到同步。</p><h4 id="主从级联"><a href="#主从级联" class="headerlink" title="主从级联"></a>主从级联</h4><p>在进行数据同步时，主库进行了两个非常耗时的操作，生成RDB文件和传输RDB文件</p><p>为了分担主库的压力，可以采用主-从-从的方式来，将主库生成RDB和传输RDB的工作级联给从库来执行。</p><p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p><p><img src="https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg?wh=3543*1791" alt="img"></p><h4 id="主从库之间网络断连了怎么办"><a href="#主从库之间网络断连了怎么办" class="headerlink" title="主从库之间网络断连了怎么办"></a>主从库之间网络断连了怎么办</h4><p>在主从库完成全量复制之后，主从库之间就会维护一个网络连接，通过这个连接把后续的操作发给从库，避免了频繁建立连接的开销，但是却有了网络断联和阻塞的问题</p><p>采用增量复制的方式来实现同步，其中使用了repl-backlog-buffer缓冲区。</p><p>这个缓冲区是环形缓冲区，主库写入，从库读取，这样的操作流程，在发生网络断联的时候，主库继续在写入，则主库写入进度比从库读取进度要快，网络连接恢复的时候，从库发出请求，并且把自己读取到了哪里的位置发给主库，主库判断从库读取到的位置，然后和自己写入的位置进行比较，把这两者之间的数据发送给从库。</p><p>由于是环形缓冲区，如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p><ol><li>一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。 </li><li>每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。</li></ol><p>解决这个问题我们可以调高缓冲区的大小或者切片集群。</p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>如果主库挂了，那我们就需要一个新的主库，比如把一个从库变成新的主库，这涉及到三个问题</p><p>1.主库真的挂了吗</p><p>2.谁来当新主库</p><p>3.怎么把新主库的相关信息通知给从库和客户端</p><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><p>哨兵就是运行在redis上的一个进程，它有三个任务，监控，选主，通知</p><h4 id="监控："><a href="#监控：" class="headerlink" title="监控："></a>监控：</h4><p>哨兵在运行时会周期性的给所有的主从库发送ping命令，检测它是否是在线状态，如果从库没有响应，哨兵就会判定他是下线状态，主库如果不响应，就会判断主库下线，开始自动转换主库的流程</p><h4 id="选主："><a href="#选主：" class="headerlink" title="选主："></a>选主：</h4><p>主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</p><h4 id="通知："><a href="#通知：" class="headerlink" title="通知："></a>通知：</h4><p>哨兵会把新主库的信息发送给其他从库，让它们和新主库建立连接，进行数据复制，同时通知客户端，以后的请求发给新主库</p><h4 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h4><p>哨兵在监控主库是否下线的时候可能受制于自己的网络问题等原因发生误判，也就是主库其实没有下线，但哨兵认为它下线开始了主从切换，主从切换过程资源消耗较大。</p><p>因此为了避免出现误判，引入了多实例组成的集群模式进行部署哨兵，多个哨兵一起判断这个主库是否下线了，避免单个哨兵网络不好的情况</p><p>主观下线就是某个哨兵认为主库下线了，客观下线是一定量的哨兵都认为主库下线了，主库才会被标记为客观下线</p><p>最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。（多少实例，管理员可以调）</p><p><img src="https://static001.geekbang.org/resource/image/19/0d/1945703abf16ee14e2f7559873e4e60d.jpg?wh=3807*1416" alt="img"></p><h4 id="如何选择新主库"><a href="#如何选择新主库" class="headerlink" title="如何选择新主库"></a>如何选择新主库</h4><p>选主库的过程主要是两个“筛选+打分”。</p><p><img src="https://static001.geekbang.org/resource/image/f2/4c/f2e9b8830db46d959daa6a39fbf4a14c.jpg?wh=3671*1743" alt="img"></p><p>筛选：筛选的条件主要是从库要在线，但是在选举时候从库在线不够有说服力，可能它过一会就下线了，所以除了检查从库的当前状态， 还要检查从库之前的网络状态，如果它经常和之前的主库断联说明它的网络状态不太好，不适合做新主库。这里有一个阈值判断，断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p><p>打分：</p><p>第一轮：优先级最高的从库得分最高</p><p>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p><p>第二轮：和旧主库同步程度最接近的从库得分高。</p><p>这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。</p><p>我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。</p><p>第三轮：ID号小的从库得分高</p><p>在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p><h4 id="基于pub-sub机制的哨兵集群组成"><a href="#基于pub-sub机制的哨兵集群组成" class="headerlink" title="基于pub/sub机制的哨兵集群组成"></a>基于pub/sub机制的哨兵集群组成</h4><p>pub/sub机制就是发布订阅机制</p><p>部署哨兵集群的时候，配置哨兵时只设置了主库的信息，并没有给其他哨兵的连接信息，那么哨兵之间是如何连接上的呢？</p><p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p><p>除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。</p><p><img src="https://static001.geekbang.org/resource/image/ca/b1/ca42698128aa4c8a374efbc575ea22b1.jpg?wh=2822*1535" alt="img"></p><p>哨兵除了彼此要形成集群外，还需要和从库建立连接，方便监控</p><p>这是由哨兵向主库发送 INFO 命令来完成的。主库会把从库列表给哨兵</p><p><img src="https://static001.geekbang.org/resource/image/88/e0/88fdc68eb94c44efbdf7357260091de0.jpg?wh=2499*1404" alt="img"></p><p>但是，哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成把新主库的信息告诉客户端这个任务。</p><p>从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p><h4 id="有哪个哨兵进行主从切换"><a href="#有哪个哨兵进行主从切换" class="headerlink" title="有哪个哨兵进行主从切换"></a>有哪个哨兵进行主从切换</h4><p>确定由哪个哨兵执行主从切换的过程，和主库“客观下线”的判断过程类似，也是一个“投票仲裁”的过程。</p><p>客观下线的流程：</p><p>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p><p><img src="https://static001.geekbang.org/resource/image/e0/84/e0832d432c14c98066a94e0ef86af384.jpg?wh=2322*1260" alt="img"></p><p>此时，这个哨兵就开始再给其他哨兵发送命令，希望自己来执行主从切换，并且让其他哨兵投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。</p><p>想成为leader，要满足两个条件：拿到半数以上的赞成票，且票数高于等于配置文件中的quorum值。</p><p><img src="https://static001.geekbang.org/resource/image/5f/d9/5f6ceeb9337e158cc759e23c0f375fd9.jpg?wh=2843*1934" alt="img"></p><p>如果 S3 没有拿到 2 票 Y，那么这轮投票就不会产生 Leader。哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的 2 倍），再重新选举。这是因为，哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或有短时堵塞，就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p><p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。这一点很重要，实际应用时可不能忽略了。</p><h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><h4 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h4><p>分片集群，指启动多个Redis实例组成一个集群，然后按一定的规则把收到的划分成多份，每一份用一个实例来保存。</p><h4 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h4><p>在切片集群中，数据和实例是如何对应的呢？</p><p>Redis CLuster方案采用哈希槽的方式处理数据和实例的映射关系。</p><p>在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p><p>映射过程：首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p><p>然后把这些槽平均分配给实例上，例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string类型提供了一个键对应一个值的保存形式，而且string可以保存二进制字节流，只要把数据转换成二进制字节数组就可以保存。</p><p>string类型并不是适合所有场景的，它有一个明显的短板，那就是它保存数据的时候所消耗的内存空间较多</p><h4 id="为什么string类型空间消耗大"><a href="#为什么string类型空间消耗大" class="headerlink" title="为什么string类型空间消耗大"></a>为什么string类型空间消耗大</h4><p>其实，除了记录实际数据之外，string还会记录数据长度，空间使用等信息，也被叫做元数据。</p><p>当保存的数据较小的时候，元数据的空间开销就会显得比较大。</p><p>String是如何保存数据的呢？</p><p>当你保存64位有符号整数时，String类型把它保存在一个8字节的Long类型整数，这种方式被称为int编码</p><p>当年保存的数据包含字符，就会采用简单动态字符串结构体来保存</p><p><img src="https://static001.geekbang.org/resource/image/37/57/37c6a8d5abd65906368e7c4a6b938657.jpg?wh=1926*1400" alt="img"></p><p>如图，会有四个字节保存数据长度，四个字节保存实际分配长度，buf才是保存实际数据的部分。</p><p>除此之外，对于String来说还有一个redisObject的结构体的开销。</p><p>因为redis数据类型很多，所以会有很多数据类型有相同元数据保存的情况出现（比如最后一次保存时间这种），所以redis采用redisObject的方式来存储这种元数据，并且指向实际数据。</p><p>一个RedisObject包含一个8字节的元数据和8字节的字节指针，字节指针指向具体数据类型的实际的数据所在，例如指向string的sds结构所在的内存地址。</p><p><img src="https://static001.geekbang.org/resource/image/34/57/3409948e9d3e8aa5cd7cafb9b66c2857.jpg?wh=2214*1656" alt="img"></p><p>为了节省空间，Redis对Long类型数据和SDS的内存布局做了优化。</p><p>一方面，保存的数据是long类型数据的话，RedisObject的指针就直接赋值给整数数据了，不会再用额外的指针，节省开销</p><p>另一方面，保存的是字符型数据的话，并且字符数据小于44个字节，就会把RedisObject的元数据，指针，SDS放在一块连续的区域里面，避免内存碎片，这种布局被称为embstr编码方式。</p><p>当然，当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。</p><p><img src="https://static001.geekbang.org/resource/image/ce/e3/ce83d1346c9642fdbbf5ffbe701bfbe3.jpg?wh=3072*1938" alt="img"></p><p>redis会用一个全局哈希表来保存所有键值对，哈希表的每一项是一个dictEntry的结构体，用来指向一个键值对，其中用三个8字节的指针，分别指向key，value，next，共24字节。</p><p><img src="https://static001.geekbang.org/resource/image/b6/e7/b6cbc5161388fdf4c9b49f3802ef53e7.jpg?wh=2219*1371" alt="img"></p><p>，但事情还没有完，Redis的内存分配库jemalloc，它并不是申请多大的空间就给多大的空间， 而是会比你申请的空间多分配到比这个数大的最近的2的次幂，这样可以减少频繁的分配空间。</p><p>比如申请六个字节，就分配8个字节，24个字节就分配32个字节。</p><p>这些各种加起来，导致string类型空间消耗大起来了。</p><h4 id="用什么数据结构可以节省内存"><a href="#用什么数据结构可以节省内存" class="headerlink" title="用什么数据结构可以节省内存"></a>用什么数据结构可以节省内存</h4><p>压缩列表可以</p><p>压缩列表的构成。表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。</p><p><img src="https://static001.geekbang.org/resource/image/f6/9f/f6d4df5f7d6e80de29e2c6446b02429f.jpg?wh=3457*972" alt="img"></p><p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。</p><p>pre：1或者5字节</p><p>encoding：1字节</p><p>len：4字节</p><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p><p>Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p><h4 id="如何用集合类型保存单值的键值对"><a href="#如何用集合类型保存单值的键值对" class="headerlink" title="如何用集合类型保存单值的键值对"></a>如何用集合类型保存单值的键值对</h4><p>在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。</p><p>以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。</p><p>Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表。</p><p>那么什么时候用压缩列表，什么时候用哈希表呢</p><p>其实，Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。</p><p>这两个阈值分别对应以下两个配置项：</p><p>hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。</p><p>hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。</p><p>一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。</p><p>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。</p><h3 id="redis可以做消息队列吗"><a href="#redis可以做消息队列吗" class="headerlink" title="redis可以做消息队列吗"></a>redis可以做消息队列吗</h3><p>这个问题隐含着两个问题：</p><p>消息队列的消息存取需求是什么</p><p>redis如何实现消息队列的消息存取需求</p><h4 id="消息队列的消息存取需求"><a href="#消息队列的消息存取需求" class="headerlink" title="消息队列的消息存取需求"></a>消息队列的消息存取需求</h4><p>在分布式系统中，当两个组件要基于消息队列进行通信的时候，一个组件会被要处理的请求放入消息队列中，自己就可以执行其他操作了，远端的另一个组件从队列中把消息队列取出来，再在本地进行处理</p><p>假设组件 1 需要对采集到的数据进行求和计算，并写入数据库，但是，消息到达的速度很快，组件 1 没有办法及时地既做采集，又做计算，并且写入数据库。所以，我们可以使用基于消息队列的通信，让组件 1 把数据 x 和 y 保存为 JSON 格式的消息，再发到消息队列，这样它就可以继续接收新的数据了。组件 2 则异步地从消息队列中把数据读取出来，在服务器 2 上进行求和计算后，再写入数据库。这个过程如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d7/bc/d79d46ec4aa22bf46fde3ae1a99fc2bc.jpg?wh=3000*1459" alt="img"></p><p>我们一般把消息队列中发送消息的组件称为生产者（例子中的组件 1），把接收消息的组件称为消费者</p><p>在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是消息队列作为分布式组件通信的一大优势。</p><h5 id="消息保序"><a href="#消息保序" class="headerlink" title="消息保序"></a>消息保序</h5><p>虽然消费者的信息是异步处理的，但是消息仍然需药按照生产者发送消息的顺序来处理消息，避免后发送的信息被先处理了</p><h5 id="重复消息处理"><a href="#重复消息处理" class="headerlink" title="重复消息处理"></a>重复消息处理</h5><p>消费者从消息队列读取信息时，有时会因为网络堵塞导致消息重传，此时如果消费者重复执行了相同的消息，如果消息是修改数据，就会导致数据出错。</p><h5 id="消息可靠性保证"><a href="#消息可靠性保证" class="headerlink" title="消息可靠性保证"></a>消息可靠性保证</h5><p>消费者在处理消息的时候，可能会出现故障或者宕机导致消息没处理的情况。也就是说，当消费者重启时，需要保证重新从消息队列里面读取信息再次处理。</p><h4 id="基于List的消息队列解决方案"><a href="#基于List的消息队列解决方案" class="headerlink" title="基于List的消息队列解决方案"></a>基于List的消息队列解决方案</h4><p>List本身是先进先出的顺序对数据进行存取，所以满足消息保序的需求。</p><p>不过，在生产者在写入数据时，list不会主动通知消费者有新消息写入了，如果消费者要处理消息，只能一直不停调用RPOP命令，带来了性能损失，为了解决这个问题，redis提供了阻塞形式的BRPOP，客户端在没有读到队列数据时，自动阻塞，知道队列有新数据写入队列，再开始读取新数据。</p><p>为了解决重复消息处理的问题，消息队列给每个消息提供全局ID，并且把处理过的ID记录下来</p><p>为了解决消息处理可靠性的问题，redis在消费者读取了消息后，会把这个消息存入另一个list里面去，这样如果在读取时候消费者挂了，重启后可以去备份里面读取消息处理。</p><p>问题出现了：生产者发送数据的数据太快了，但是消费者处理数据的速度太慢，会导致大量数据堆积在list中，给redis的内存带来很大的压力。</p><p>这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。</p><p>因此我们引入了Stream</p><h4 id="基于Streams的消息队列的解决方案"><a href="#基于Streams的消息队列的解决方案" class="headerlink" title="基于Streams的消息队列的解决方案"></a>基于Streams的消息队列的解决方案</h4><p>Streams是redis专门为消息队列设计的数据类型</p><h5 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h5><p>XADD 命令可以往消息队列中插入新消息，消息的格式是键 - 值对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。</p><h5 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h5><p>XREAD 在读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。另外，消费者也可以在调用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。</p><h5 id="XGROUP"><a href="#XGROUP" class="headerlink" title="XGROUP"></a>XGROUP</h5><p>Streams 本身可以使用 XGROUP 创建消费组，创建消费组之后，Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p><p>为了保障消费者宕机后，仍然可以处理读取为处理的数据。</p><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p><h3 id="redis的异步机制"><a href="#redis的异步机制" class="headerlink" title="redis的异步机制"></a>redis的异步机制</h3><h4 id="redis实例的阻塞点"><a href="#redis实例的阻塞点" class="headerlink" title="redis实例的阻塞点"></a>redis实例的阻塞点</h4><ol><li>集合全量查询和聚合操作</li><li>bigkey删除</li><li>清空数据库</li><li>AOF日志同步写</li><li>从库加载RDB文件</li></ol><h4 id="可以异步执行的阻塞点"><a href="#可以异步执行的阻塞点" class="headerlink" title="可以异步执行的阻塞点"></a>可以异步执行的阻塞点</h4><ol><li>bigkey删除</li><li>清空数据库</li><li>AOF文件同步写</li></ol><p>首先，什么是异步，所谓的异步线程机制，就是指，Redis 会启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。使用异步线程机制执行操作，可以避免阻塞主线程。</p><p>那么判断一个操作能不能异步执行的关键点是什么呢，看它是不是redis主线程关键路径上的操作。这就是说，客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作。</p><h4 id="异步的子线程机制"><a href="#异步的子线程机制" class="headerlink" title="异步的子线程机制"></a>异步的子线程机制</h4><p>redis主线程启动后，会使用操作系统的函数创造三个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p><p>主线程通过一个链表形式的任务列表和子线程交互，当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。</p><h3 id="CPU架构对Redis性能的影响"><a href="#CPU架构对Redis性能的影响" class="headerlink" title="CPU架构对Redis性能的影响"></a>CPU架构对Redis性能的影响</h3><h4 id="主流的CPU架构"><a href="#主流的CPU架构" class="headerlink" title="主流的CPU架构"></a>主流的CPU架构</h4><p>一个cpu处理器有多个运行核心，每个运行核心称为一个物理核，每个物理核有自己的私有缓存L1，和私有的二级缓存L2。</p><p>什么是私有缓存，就是只有当前这个物理核访问，其他核心不能访问。</p><p>因为每个L1，L2是物理核私有的，所以它的存取速度非常快，数据保存在这里，就能高速的存取。</p><p>但是L1，L2受限于技术，空间并不大，因此不同的物理核之间又共享了一个L3，L3空间要大很多。</p><p>另外，每个物理核，还会运行两个超线程，也叫做逻辑核。同一个物理核的逻辑核会共享L1，L2缓存。</p><p><img src="https://static001.geekbang.org/resource/image/d9/09/d9689a38cbe67c3008d8ba99663c2f09.jpg?wh=3065*1633" alt="img"></p><p>在主流cpu服务器上，一个服务器会有多个CPU处理器，也叫CPU Socket。</p><p><img src="https://static001.geekbang.org/resource/image/5c/3d/5ceb2ab6f61c064284c8f8811431bc3d.jpg?wh=3000*1252" alt="img"></p><p>但是在多CPU架构上，会出现一个问题，那就是如果应用程序在socket 1上面运行了一段时间，并且把数据存储到了内存中，然后它被调度到了socket 2上面运行，这个时候它想要访问当时存到socket 1下面内存的数据时候，这个操作会比直接访问和socket 直接相连的内存要慢。</p><p>在多 CPU 架构下，一个应用程序访问所在 Socket 的本地内存和访问远端内存的延迟并不一致，所以，我们也把这个架构称为非统一内存访问架构，也就是NUMA 架构</p><h4 id="CPU多核对性能的影响"><a href="#CPU多核对性能的影响" class="headerlink" title="CPU多核对性能的影响"></a>CPU多核对性能的影响</h4><p>CPU多核，如果应用程序频繁的被不同核心所运行， 那么就会降低效率，因为这会导致频繁地上下文切换，因此，我们应该把一个redis实例和一个核心绑定，这样可以提升redis的性能，用taskset来绑定。</p><h4 id="如何避免绑核后的线程竞争"><a href="#如何避免绑核后的线程竞争" class="headerlink" title="如何避免绑核后的线程竞争"></a>如何避免绑核后的线程竞争</h4><p>Redis除了主线程外，还有子线程需要工作，所以如果绑在一个核心上就会出现多个线程竞争的情况，会导致主线程阻塞。</p><p>为了避免这个情况，有两种方法</p><p>方案一：一个 Redis 实例对应绑一个物理核</p><p>这样可以充分利用物理核的两个逻辑核，因为有两个所以可以减少线程竞争的情况</p><p>方案二：优化 Redis 源码</p><p>这个方案就是通过修改 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上。</p><h3 id="Redis变慢了"><a href="#Redis变慢了" class="headerlink" title="Redis变慢了"></a>Redis变慢了</h3><h4 id="Redis自身操作特性的影响"><a href="#Redis自身操作特性的影响" class="headerlink" title="Redis自身操作特性的影响"></a>Redis自身操作特性的影响</h4><h5 id="1-慢查询命令"><a href="#1-慢查询命令" class="headerlink" title="1.慢查询命令"></a>1.慢查询命令</h5><p>慢查询命令，就是在redis上执行速度比较慢的命令，会导致redis延迟增加。</p><p>解决方法：尽量避免使用慢查询命令，替换成更高效的方法。当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</p><h5 id="2-过期KEY操作"><a href="#2-过期KEY操作" class="headerlink" title="2.过期KEY操作"></a>2.过期KEY操作</h5><p>首先需要知道，redis自己本身就有过期key自动删除机制。</p><p>机制的算法如下：</p><ol><li>采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；</li><li>如果超过25%的key过期了，则重复删除的操作，知道过期key的比率降到25%一下。</li></ol><p>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 是 Redis 的一个参数，默认是 20，那么，一秒内基本有 200 个过期 key 会被删除。</p><p>但是如果触发了算法的第二条，redis就会一直删除来释放空间，但是删除操作本身是阻塞的（4.0后可以异步执行），会导致redis变慢。</p><p>解决方法：避免使用带有相同时间参数的key命令，只会导致它们会一起过期。</p><h4 id="文件系统对redis的影响"><a href="#文件系统对redis的影响" class="headerlink" title="文件系统对redis的影响"></a>文件系统对redis的影响</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>redis采用aof日志模式的时候，提供了三种写回策略，no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。</p><p>write只要把日志记录到缓冲区就返回了，并不需要等日志实际写到磁盘，而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。</p><p><img src="https://static001.geekbang.org/resource/image/9f/a4/9f1316094001ca64c8dfca37c2c49ea4.jpg?wh=2720*598" alt="img"></p><p>其中everysec策略时，redis使用后台子进程异步完成fsync操作。</p><p>但always不行，always使用的主线程来完成。</p><p>除此之外，另外，在使用 AOF 日志时，为了避免日志文件不断增大，Redis 会执行 AOF 重写，生成体量缩小的新的 AOF 日志文件。AOF 重写本身需要的时间很长，也容易阻塞 Redis 主线程，所以，Redis 使用子进程来进行 AOF 重写。</p><p>但是，AOF重写会进行大量的磁盘IO操作，同时，fsync又需要等到数据写到磁盘才能返回，当AOF重写压力大的时候，就会导致fsync阻塞，虽然它在子线程进行，但是主线程会监视子线程，如果子线程阻塞，主线程发现上一次给子线程的fsync没有执行完，那么它就会阻塞，性能变慢。</p><p><img src="https://static001.geekbang.org/resource/image/2a/a6/2a47b3f6fd7beaf466a675777ebd28a6.jpg?wh=3000*1557" alt="img"></p><h4 id="操作系统对redis的影响"><a href="#操作系统对redis的影响" class="headerlink" title="操作系统对redis的影响"></a>操作系统对redis的影响</h4><h5 id="1-swap"><a href="#1-swap" class="headerlink" title="1.swap"></a>1.swap</h5><p>内存swap是操作系统将内存数据和磁盘数据来回换入换出的机制，涉及到磁盘的读写。所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。</p><p>而且，和我刚才说的 AOF 日志文件读写使用 fsync 线程不同，swap 触发后影响的是 Redis 主 IO 线程，这会极大地增加 Redis 的响应时间。</p><p>通常，触发 swap 的原因主要是物理机器内存不足</p><p>解决思路：增加机器的内存或者使用 Redis 集群。</p><h5 id="2-内存大页"><a href="#2-内存大页" class="headerlink" title="2.内存大页"></a>2.内存大页</h5><p>redis为了保证数据可靠性，需要对数据进行持久化操作，如果此时客户端对redis进行写入数据，数据涉及到正在持久化的数据，那么redis就会曹勇写时复制机制，会对数据页进行拷贝，如果采用内存大页，可能100kb的数据进行修改，也需要复制2MB的大页，导致性能变慢。</p><p>解决方法：关闭内存大页。</p><h3 id="旁路缓存，redis如何工作的"><a href="#旁路缓存，redis如何工作的" class="headerlink" title="旁路缓存，redis如何工作的"></a>旁路缓存，redis如何工作的</h3><h4 id="缓存的特征"><a href="#缓存的特征" class="headerlink" title="缓存的特征"></a>缓存的特征</h4><p>首先，一个系统不同层的访问速度不一样，我们才需要缓存。</p><p>这样就可以把一些需要频繁访问的数据放在缓存中，以加快它们的访问速度。例如：</p><p><img src="https://static001.geekbang.org/resource/image/7d/44/7dyycf727f9396eb9788644474855a44.jpg?wh=2156*1239" alt="img"></p><p>计算机系统中，默认有两种缓存：</p><p>CPU 里面的末级缓存，即 LLC，用来缓存内存中的数据，避免每次从内存中存取数据；内</p><p>存中的高速页缓存，即 page cache，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。</p><p>缓存两大特征：</p><p>在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。</p><p>缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。</p><h4 id="redis缓存处理请求的方式"><a href="#redis缓存处理请求的方式" class="headerlink" title="redis缓存处理请求的方式"></a>redis缓存处理请求的方式</h4><h5 id="缓存命中："><a href="#缓存命中：" class="headerlink" title="缓存命中："></a>缓存命中：</h5><p>Redis 中有相应数据，就直接读取 Redis，性能非常快。</p><h5 id="缓存缺失："><a href="#缓存缺失：" class="headerlink" title="缓存缺失："></a>缓存缺失：</h5><p>Redis 中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入 Redis，这个过程叫作缓存更新。</p><p><img src="https://static001.geekbang.org/resource/image/6b/3d/6b0b489ec0c1c5049c8df84d77fa243d.jpg?wh=2750*1631" alt="img"></p><h4 id="redis缓存类型"><a href="#redis缓存类型" class="headerlink" title="redis缓存类型"></a>redis缓存类型</h4><h5 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h5><p>当redis用作只读缓存时，读请求会先在缓存中查看数据是否存在。而写请求则全部交给数据库，在数据库中增删改，对于删除的数据来说，如果redis已经缓存了相应的数据，应用需要把这些缓存的数据删除，redis中就没有这些数据了。</p><p>只读缓存好处是，保证了最新的数据在数据库里面，数据库有可靠性保障，数据更安全。</p><h5 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h5><p>对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。</p><p>但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在 Redis 中，而 Redis 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。</p><p>因此它提供了两个策略</p><ol><li>同步直写，写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。</li><li>异步写回，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。</li></ol><h3 id="redis缓存淘汰策略"><a href="#redis缓存淘汰策略" class="headerlink" title="redis缓存淘汰策略"></a>redis缓存淘汰策略</h3><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。</p><p>我们可以按照是否会进行数据淘汰把它们分成两类：</p><p>不进行数据淘汰的策略，只有 noeviction 这一种。</p><p>会进行淘汰的 7 种其他策略。</p><p>会进行淘汰的 7 种策略，我们可以再进一步根据淘汰候选数据集的范围把它们分成两类：</p><p>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。</p><p>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种。</p><p><img src="https://static001.geekbang.org/resource/image/04/f6/04bdd13b760016ec3b30f4b02e133df6.jpg?wh=1757*765" alt="img"></p><p>noevction：它不进行淘汰，满了后就不再提供服务。</p><p>volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu：它们筛选的候选数据范围，被限制在已经设置了过期时间的键值对上。也正因为此，即使缓存没有写满，这些数据如果过期了，也会被删除。</p><p>allkeys-lru、allkeys-random、allkeys-lfu：淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。</p><h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><p>LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</p><p>LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据。</p><p><img src="https://static001.geekbang.org/resource/image/02/y5/0201f85c84203300ae4085c60e955yy5.jpg?wh=1702*1678" alt="img"></p><p>如果有一个新数据 15 要被写入缓存，但此时已经没有缓存空间了，也就是链表没有空余位置了，</p><p>那么，LRU 算法做两件事：数据 15 是刚被访问的，所以它会被放到 MRU 端；算法把 LRU 端的数据 5 从缓存中删除，相应的链表中就没有数据 5 的记录了。</p><p>不过，LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p><p>Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。</p><p>具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p><p>当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。</p><h4 id="如何处理被淘汰的数据"><a href="#如何处理被淘汰的数据" class="headerlink" title="如何处理被淘汰的数据"></a>如何处理被淘汰的数据</h4><p>一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写回数据库</p><p>干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。</p><p>干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。</p><p>而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p><h3 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h3><h4 id="缓存数据和数据库不一致"><a href="#缓存数据和数据库不一致" class="headerlink" title="缓存数据和数据库不一致"></a>缓存数据和数据库不一致</h4><p>对于读写缓存，可以采用同步写回策略</p><p>对于只读缓存</p><p><img src="https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg?wh=2889*1355" alt="img"></p><p>其中先删除缓存值，再更新数据库的操作中，重试数据库更新是用消息队列来实现</p><p>其中先删除缓存值，再更新数据库的操作中，延迟双删是指执行删除的线程1在更新数据库后，sleep一段时间，让来读取这个数据的线程2读数据，发现缓存没有，然后从数据库中找到值更新过去，由于是并发执行的，这里线程2读到的可能是旧值，因此需要删除这个存到缓存的数据，然后sleep醒过来的线程1再进行删除线程2更新的缓存。这之后的线程就发现缓存中没有，去数据库读到最新值了。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指大量的应用请求无法在redis缓存中进行处理，紧接着大量请求发送给数据库层，数据库压力激增。</p><p>原因：</p><ol><li>缓存中有大量数据同时过期，导致大量数据无法得到处理</li></ol><p>​解决方案：</p><p>​1.避免给大量数据设置相同的过期时间，就算是业务要求有些数据时间相同，可以使用EXPIRE给每个数据设置过期时间的时候，加上一个较小的随机数。</p><p>​2. 服务降级，就是当业务访问的是非核心数据时，就暂停从缓存中查询这些数据，而是直接返回预定义信息，空值，或错误信息。当业务访问的是核心数据时，就仍然允许查询缓存，如果需要访问数据库，也允许</p><pre><code>2. redis缓存实例发送故障宕机了，无法处理请求，大量请求堆积到数据库层</code></pre><p>​解决方法：</p><p>​1.在业务系统中实现服务熔断，即业务应用调用缓存接口时，缓存客户端并不把请求发送给redis缓存实例，而是直接返回，等到redis缓存实例重启后，再运行请求发送到缓存实例。</p><p>​2.请求限流，在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</p><p>​3.构建redis高可用缓存集群，主节点挂掉后，从节点替换主节点继续提供服务。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿就是大量的热点数据同时过期，导致大量请求访问到数据层</p><p>解决方法：对于访问特别频繁的数据可以不设置过期时间。或者提前预热，把热点数据重新存入，设置好过期时间。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。</p><p>第一种方案：缓存空值或缺省值</p><p>第二种方案：使用布隆过滤器快速判断数据是否存在，避免从数据库查询数据。</p><p>布隆过滤器怎么工作的呢？</p><p>布隆过滤器由一个初值为0的bit数组和N个哈希函数组成，可以用来快速判断某个数据是否存在。</p><p>如何标记一个数存在：</p><ul><li>首先，使用N个哈希函数对数据求哈希值，得到N个哈希值</li><li>把这N个哈希值对bit数组的长度取模，得到哈希值在数组中的对应位置</li><li>最后，把对应位置的bit位设置为1。</li></ul><p>当需要查询这个数据时，我们就执行刚刚说的计算过程，先得到这个数据在bit数组中对应的N个位置，紧接着查看这N个位置的bit值，有一个不为1就说明数据库中不存在这个数据。</p><p><img src="https://static001.geekbang.org/resource/image/98/68/98f7d32499e4386b40aebc3622aa7268.jpg?wh=2953*1342" alt="img"></p><p>第三种方案，在请求入口的前端进行请求检测。</p><h4 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>有些数据访问次数很少，被访问一次后很久都不会再被访问了，但是它们仍然占据了缓存空间，这就是缓存污染</p><h5 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h5><p>redis采用的是LFU算法，LFU算法采取的策略是，首先根据数据的访问次数来筛选，把访问次数最低的淘汰，如果数据访问次数一样，就比较数据的访问时效性，把距离上一次访问最远的淘汰。</p><p>实现上面，仍然和LRU算法一样，采取RedisObject的lru字段来存储数据的时间戳和访问次数</p><p>前16位记录时间戳，后8位记录访问次数</p><p>问题来了，8位只能记录到255次，这个数据太小了，很容易填满。</p><p>redis为了防止这种情况出现，设置了一种非线性增长的方法来增加count次数</p><p>那就是，数据每被访问一次，就把它和配置项相乘加一，然后取倒数，得到的值和0到1的随机数比较，如果大于随机数，就加1。</p><p>使用了这种计算规则后，我们可以通过设置不同的 lfu_log_factor 配置项，来控制计数器值增加的速度，避免 counter 值很快就到 255 了。</p><p>在一些场景下，有些数据在短时间内被大量访问后就不会再被访问了。那么再按照访问次数来筛选的话，这些数据会被留存在缓存中，但不会提升缓存命中率。为此，Redis 在实现 LFU 策略时，还设计了一个 counter 值的衰减机制。</p><p>LFU 策略使用衰减因子配置项 lfu_decay_time 来控制访问次数的衰减。LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。</p><h3 id="原子操作来实现并发"><a href="#原子操作来实现并发" class="headerlink" title="原子操作来实现并发"></a>原子操作来实现并发</h3><p>为了实现并发访问的正确性，redis提供了两种方法，加锁和原子操作，但是由于加锁会降低redis的性能，所以推荐使用原子操作的方式。</p><p>并发访问操作主要是对数据进行修改，分为读取，修改，写回这三步，如果不对其控制，会导致错误。</p><p>redis提供了两种方法避免这个问题</p><h4 id="单命令操作"><a href="#单命令操作" class="headerlink" title="单命令操作"></a>单命令操作</h4><p>由于redis本身是单命令操作的，命令之间是互斥的。所以我们可以把读取，修改，写回，这三个步骤变成一个命令，单命令，再加上redis的互斥，就能保障并发控制了。</p><p>比如INCR/DECR</p><h4 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h4><p>但是有些命令，没那么简单，需要根据实际需求去调整，这个时候我们可以采用Lua脚本的方式。Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。</p><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><h4 id="基于单节点的分布式锁"><a href="#基于单节点的分布式锁" class="headerlink" title="基于单节点的分布式锁"></a>基于单节点的分布式锁</h4><p>使用setnx命令，这个命令在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。</p><p>对于释放锁操作来说，我们可以在执行完业务逻辑后，使用 DEL 命令删除锁变量。</p><p>不过这样仍然有风险：</p><p>第一个风险：假如某个客户端在执行了 SETNX 命令、加锁之后，紧接着却在操作共享数据时发生了异常，结果一直没有执行最后的 DEL 命令释放锁。</p><p>针对这个问题，一个有效的解决方法是，给锁变量设置一个过期时间。</p><p>第二个风险。如果客户端 A 执行了 SETNX 命令加锁后，假设客户端 B 执行了 DEL 命令释放锁，此时，客户端 A 的锁就被误释放了。如果客户端 C 正好也在申请加锁，就可以成功获得锁，进而开始操作共享数据。这样一来，客户端 A 和 C 同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。</p><p>给客户端加上唯一标识来解决第二个风险。</p><p>因为在加锁操作中，每个客户端都使用了一个唯一标识，所以在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识</p><p>//释放锁 比较unique_value是否相等，避免误释放<br>if redis.call(“get”,KEYS[1]) == ARGV[1] then<br>    return redis.call(“del”,KEYS[1])<br>else<br>    return 0<br>end</p><p>为什么要用Lua脚本，因为其中包含了读取锁变量，判断值，删除锁变量这三个 操作，所以需要原子性操作。</p><h4 id="基于多节点的分布式锁"><a href="#基于多节点的分布式锁" class="headerlink" title="基于多节点的分布式锁"></a>基于多节点的分布式锁</h4><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。</p><p>第一步是，客户端获取当前时间。第二步是，客户端按顺序依次向 N 个 Redis 实例执行加锁操作。</p><p>第三步是，一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</p><h3 id="redis的ACID"><a href="#redis的ACID" class="headerlink" title="redis的ACID"></a>redis的ACID</h3><h4 id="什么是ACID"><a href="#什么是ACID" class="headerlink" title="什么是ACID"></a>什么是ACID</h4><p>第一个是原子性：事务中的多个操作必须都完成，或者都不完成</p><p>第二个是一致性：数据库中的数据在事务执行前后是一致的，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><p>第三个是隔离性：数据库在执行一个事务的时候，其他操作无法存取正在执行事务访问的数据</p><p>第四个是持久性：数据库执行事务后，数据的修改要被持久化保存下来。</p><h4 id="Redis如何实现事务"><a href="#Redis如何实现事务" class="headerlink" title="Redis如何实现事务"></a>Redis如何实现事务</h4><p>redis用MULTI、EXEC两个命令来完成。</p><p>第一步，客户端使用multl开启事务</p><p>第二步，客户端发送命令到服务器端，这些操作就是redis本身提供的数据读写命令，这些命令虽然被传到服务器端但是不会真的被执行，而是会暂存到一个命令队列里面。</p><p>第三步，客户端发送EXEC，服务端真正执行事务</p><h4 id="Redis的事务机制能保证哪些属性"><a href="#Redis的事务机制能保证哪些属性" class="headerlink" title="Redis的事务机制能保证哪些属性"></a>Redis的事务机制能保证哪些属性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>命令入队时就报错，会放弃事务执行，保证原子性</p><p>命令入队时未检测出来，实际执行时会报错，不能保证原子性</p><p>EXEC命令执行时，redis实例故障，如果开启了AOF日志，可以保证原子性</p><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>情况1：命令入队时报错</p><p>事务会被放弃执行，可以保证一致性</p><p>情况2：命令执行时报错</p><p>错误命令不会被执行，正确命令会被执行，可以保证一致性</p><p>情况3：EXEC命令时redis实例宕机</p><p>如果没有开启AOF和RDB，那么宕机后，数据就没有了，可以保证一致性</p><p>如果开启了RDB，事务执行时是不会进行RDB快照的，所以事务命令不会保存到RDB中，可以保证一致性</p><p>如果使用了AOF，而事务操作还没有被记录到 AOF 日志时，实例就发生了故障，那么，使用 AOF 日志恢复的数据库数据是一致的。如果只有部分操作被记录到了 AOF 日志，我们可以使用 redis-check-aof 清除事务中已经完成的操作，数据库恢复后也是一致的。</p><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>分为在EXEC执行前和执行后</p><p>执行前：需要用WATCH机制来保障，</p><p>执行后：可以保证</p><p>WATCH机制：在事务执行前，监控一个或多个键的值变化情况，当事务调用EXEC命令执行时，WATCH机制会检查监控的键是否被其他客户端修改，如果被修改了，则放弃事务的执行来保障隔离性。</p><p><img src="https://static001.geekbang.org/resource/image/4f/73/4f8589410f77df16311dd29131676373.jpg?wh=3000*1921" alt="img"></p><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><p>如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。</p><p>如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。</p><p>如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。</p><p>所以，不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。</p><h3 id="Redis对秒杀场景的支持"><a href="#Redis对秒杀场景的支持" class="headerlink" title="Redis对秒杀场景的支持"></a>Redis对秒杀场景的支持</h3><h4 id="秒杀场景对系统的要求"><a href="#秒杀场景对系统的要求" class="headerlink" title="秒杀场景对系统的要求"></a>秒杀场景对系统的要求</h4><p>一个是并发量高</p><p>一个是读多写少，快速处理大量的读操作。</p><h4 id="redis在秒杀的哪些环节发挥"><a href="#redis在秒杀的哪些环节发挥" class="headerlink" title="redis在秒杀的哪些环节发挥"></a>redis在秒杀的哪些环节发挥</h4><p>第一阶段是秒杀活动前。在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量把商品详情页的页面元素静态化，然后使用 CDN 或是浏览器把这些静态化的元素缓存起来。不需要redis</p><p>第二阶段是秒杀活动开始。</p><p>此时，大量用户点击商品详情页上的秒杀按钮，会产生大量的并发请求查询库存。一旦某个请求查询到有库存，紧接着系统就会进行库存扣减。然后，系统会生成实际订单，并进行后续处理，例如订单支付和物流服务。如果请求查不到库存，就会返回。用户通常会继续点击秒杀按钮，继续查询库存。</p><p>简单来说，这个阶段的操作就是三个：库存查验、库存扣减和订单处理。因为每个秒杀请求都会查询库存，而请求只有查到有库存余量后，后续的库存扣减和订单处理才会被执行。所以，这个阶段中最大的并发压力都在库存查验操作上。</p><p>为了支撑大量高并发的库存查验请求，我们需要在这个环节使用 Redis 保存库存量，这样一来，请求可以直接从 Redis 中读取库存并进行查验。</p><p>那么，库存扣减和订单处理是否都可以交给后端的数据库来执行呢?</p><p>其实，订单处理可以在数据库中执行，但库存扣减操作，不能交给后端数据库处理。</p><p>为什么用数据库呢？</p><p>订单处理会涉及支付、商品出库、物流等多个关联操作，这些操作本身涉及数据库中的多张数据表，要保证处理的事务性，需要在数据库中完成。</p><p>那为啥库存扣减操作不能在数据库执行呢？这是因为，一旦请求查到有库存，就意味着发送该请求的用户获得了商品的购买资格，用户就会下单了。同时，商品的库存余量也需要减少一个。如果我们把库存扣减的操作放到数据库执行，会带来两个问题。</p><ol><li>额外的开销。Redis 中保存了库存量，而库存量的最新值又是数据库在维护，所以数据库更新后，还需要和 Redis 进行同步，这个过程增加了额外的操作逻辑，也带来了额外的开销。</li><li>下单量超过实际库存量，出现超售。由于数据库的处理速度较慢，不能及时更新库存余量，这就会导致大量库存查验的请求读取到旧的库存值，并进行下单。此时，就会出现下单数量大于实际的库存量，导致出现超售，这就不符合业务层的要求了。</li></ol><p><img src="https://static001.geekbang.org/resource/image/7c/1b/7c3e5def912d7c8c45bca00f955d751b.jpg?wh=2176*1582" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
